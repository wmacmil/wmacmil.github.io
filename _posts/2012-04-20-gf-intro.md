
For this inaugural blog-post, I will introduce Grammatical Framework (GF)
through an extended example targeted at a general audience familiar with logic,
functional programming, or mathematics. GF is a powerful tool for specifying
grammars. A grammar specification in GF is actually an abstract syntax. With an
abstract syntax specified, one can then define various linearization rules
which compositionally evaluate to strings. An Abstract Syntax Tree (AST) may
then be linearized to many different concrete syntaxes.  Conversely, given a
string admitted by the language being defined, GF's powerful parser will
generate all the ASTs which, linearize to that tree.

Consider a language L, for now given a single linear presentation C^L_0, where AST_L String_L0 denote the sets GF ASTs and Strings in the languages generated by the rules of L's abstract syntax and L0s compositional representation.

  Parse : String -> {AST}
  Linearize : AST -> String

with the important property that given a string s,

  forall x in (Parse s), Linearize x == s

And given an AST a, we can 
  Parse . Linearize a belongs to {AST}


Now we should explore why the linearizations are interesting. In part, this is
because they have arisen from the role of grammars have played in the
intersection and interaction between computer science and linguistics at least
since Chomsky in the 50s, and they have different understandings and utilities
in the respective disciplines. These two discplines converge in GF, which
allows us to talk about natural languages (NLs) from programming languages
(PLs) perspective. GF captures languages more expressive than Chomsky's Context
Free Grammars (CFGs) but is still decideable with parsing in (cubic?)
polynomial time, which means it still is quite domain specific and leaves a lot
to be desired as far as turing complete languages or those capable of general
recursion are concerned.

We can should note that computa

  given a string s , perhaps a phrase 
  map Linearize (Parse s)
  
is understood as the set of translations of a phrase of one language to
possibly grammatical phrases in the other languages connected by a mutual
abstract syntax. So we could denote these L^English, L^Bantu, L^Swedish for
L^Englsih_American vs L^Englsih_English or L^Bantu_i with i being any one of
the Bantu languages a hypothetical set of linguists and grammar writers may
want to implement, on a given fragment of abstract syntax, with various domain
applications, as determined by L, in mind.

  One could also further elaborate these L^English_0 L^English_1 to varying degrees of granularity, like L^English_Chomsky L^English_Partee 
  because Chomsky may something like "I was stoked" and Partee may only say something analogous "I was really excited" or whatever the individual nuances come with how speakers say what they mean with different surface syntax, and also 

  L_0 < L_1 -> L_English_0 < L_English_1

But this would be similair to a set of expressions translateable between programming languages,
like Logic^English, Logic^Latex, Logic^Agda, Logic^Coq, etc



where one could extend the 

Logic_Core^English 
Logic_Extended^English 

whereas in the PL domain 

Logic_Core^Agda Logic_Extended^Agda may collapse at certain points, but also in
some ways extend beyond our Languages capacities (we can make machine code only
machines can understand, not us)

or Mathematics = Logic + domain specific Mathematics^English Mathematics^Agda

where we could have further refinements, via, for instance, the module system, the concrete and linear designs like 

Mathematics^English
iI
-- Something about 

  The Functor (in the module sense familiar to ML programmers) 

  break down to different classifications of 

  The indexes here, while seemingly arbitrary, 

  One could also further elaborate these L^English_0 L^English_1 to varying degrees of granularity, like L^English_Chomsky L^English_Partee 

  because Chomsky may something like "I was stoked" and Partee may only say something analogous "I was really excited" or whatever the individual nuances come with how speakers say what they mean with different surface syntax, and also 






cat
  Exp ; Var ;

fun
  Add  : Exp -> Exp -> Exp ;
  Mul  : Exp -> Exp -> Exp ;
  EInt : Int -> Exp ;

Given a set of categories,  we define the functions \phi : (c_1, ..., c_n) -> c_t over the categories which will serve as the constructors of our ASTs. The categories and functions are denoted in GF with the cat and fun judgement.

The most important properties of the functions 



-- Prelude, or appendix

Prehistory : 

CFGs, Chomsky Hierarchy, BNF 

Natural Language Semantics & Martin Lof Type Theory : 



